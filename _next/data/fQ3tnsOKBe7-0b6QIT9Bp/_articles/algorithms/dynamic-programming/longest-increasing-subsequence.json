{"pageProps":{"article":{"id":"algorithms/dynamic-programming/longest-increasing-subsequence","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-increasing-subsequence.md","metadata":{"title":"Longest increasing subsequence","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming"],"categories":["Algorithms"]},"content":{"raw":"\n\n**The problem**\n\nGiven a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing\n\n**Illustration**\n\n- [1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]\n- [1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]\n\n**Solution**\n\nlet $(a_i)_{i=1}^n = N$.\n\n$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.\n\nWe can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.\n\nWe shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.\n\nTrivially,\n$$\nopt(0) = 0\n$$\n\nRecursively,\n$$\n\\forall i > 0; ~ opt(i) = 1 + \\max \\\\{ \\\\{0\\\\} \\cup \\\\{ opt(j) | j < i \\land a_j < a_i \\\\} \\\\}\n$$\n\n**Psuedo**\n\n- Initialize opt\n  - $opt \\leftarrow array(n+1)$\n  - $opt[0] \\leftarrow 0$\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n- Return the final answer\n  - $ans \\leftarrow 0$\n  - $for ~ i = 1, 2, ... n$\n    - $ans \\leftarrow max \\\\{ ans, opt[i] \\\\}$\n  - Return $ans$\n\n\n**Time Complexity**\n\n- Initialization of opt is $O(1)$ (single access to opt)\n  - We exclude the actual array creation\n- Building opt takes $O(n)$ iterations\n  - Each iteration takes $O(n)$ accesses at the worst case\n\nSo in total, the time complexity is $O(n^2)$\n\n**Finding the subsequence using a Journal**\n\nWe will keep another data structure $S$ that will act as the journal.\n\nFor each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.\n\nWe can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n    - $S[i] = $ the $j$ that achieved the max\n\nFinally, to print we shall go back from the position of the result using the indices at the journal. \n\n**Finding the subsequence using Traceback**\n\nLets review an example.\n\nAssume $N=[3, 4, 2, 7, 5]$\n\nThe final tabulation of opt will be\n\ni|0|1|2|3|4|5\n-|-|-|-|-|-|-\n$a_i$| |3|4|2|7|5\nopt(i)|0|1|2|1|3|2\n\nHere, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically\n- $opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$\n\nGenerally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j < a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0. \n\n**Actual Code**\n\n{{<codepen RwVdYyO>}}","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <nav class=\"toc\">\n      <ol class=\"toc-level toc-level-1\"></ol>\n    </nav>\n    <p><strong>The problem</strong></p>\n    <p>Given a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing</p>\n    <p><strong>Illustration</strong></p>\n    <ul>\n      <li>[1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]</li>\n      <li>[1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]</li>\n    </ul>\n    <p><strong>Solution</strong></p>\n    <p>let $(a_i)_{i=1}^n = N$.</p>\n    <p>$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.</p>\n    <p>We can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.</p>\n    <p>We shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.</p>\n    <p>\n      Trivially,\n      $$\n      opt(0) = 0\n      $$\n    </p>\n    <p>\n      Recursively,\n      $$\n      \\forall i > 0; ~ opt(i) = 1 + \\max \\{ \\{0\\} \\cup \\{ opt(j) | j &#x3C; i \\land a_j &#x3C; a_i \\} \\}\n      $$\n    </p>\n    <p><strong>Psuedo</strong></p>\n    <ul>\n      <li>\n        <p>Initialize opt</p>\n        <ul>\n          <li>$opt \\leftarrow array(n+1)$</li>\n          <li>$opt[0] \\leftarrow 0$</li>\n        </ul>\n      </li>\n      <li>\n        <p>Build opt in a bottom up fashion</p>\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Return the final answer</p>\n        <ul>\n          <li>$ans \\leftarrow 0$</li>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$ans \\leftarrow max \\{ ans, opt[i] \\}$</li>\n            </ul>\n          </li>\n          <li>Return $ans$</li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(1)$ (single access to opt)\n        <ul>\n          <li>We exclude the actual array creation</li>\n        </ul>\n      </li>\n      <li>Building opt takes $O(n)$ iterations\n        <ul>\n          <li>Each iteration takes $O(n)$ accesses at the worst case</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n    <p><strong>Finding the subsequence using a Journal</strong></p>\n    <p>We will keep another data structure $S$ that will act as the journal.</p>\n    <p>For each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.</p>\n    <p>We can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be</p>\n    <ul>\n      <li>Build opt in a bottom up fashion\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n              <li>$S[i] = $ the $j$ that achieved the max</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n    <p>Finally, to print we shall go back from the position of the result using the indices at the journal.</p>\n    <p><strong>Finding the subsequence using Traceback</strong></p>\n    <p>Lets review an example.</p>\n    <p>Assume $N=[3, 4, 2, 7, 5]$</p>\n    <p>The final tabulation of opt will be</p>\n    <div class=\"table-container\">\n      <table>\n        <thead>\n          <tr>\n            <th>i</th>\n            <th>0</th>\n            <th>1</th>\n            <th>2</th>\n            <th>3</th>\n            <th>4</th>\n            <th>5</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td>$a_i$</td>\n            <td></td>\n            <td>3</td>\n            <td>4</td>\n            <td>2</td>\n            <td>7</td>\n            <td>5</td>\n          </tr>\n          <tr>\n            <td>opt(i)</td>\n            <td>0</td>\n            <td>1</td>\n            <td>2</td>\n            <td>1</td>\n            <td>3</td>\n            <td>2</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    <p>Here, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically</p>\n    <ul>\n      <li>$opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$</li>\n    </ul>\n    <p>Generally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j &#x3C; a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0.</p>\n    <p><strong>Actual Code</strong></p>\n    <p>{{}}</p>\n  </body>\n</html>\n"}}},"__N_SSG":true}