{"pageProps":{"article":{"id":"algorithms/bloom","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/bloom.md","metadata":{"title":"Bloom Filter","description":"Illustrate the Bloomfilter data structure","priority":0,"tags":[],"categories":["Algorithms","Probabalistic Datastructures"],"toc":true},"content":{"raw":"\n## Summary\n\nA _Bloom Filter_ is an data structure that given a set of elements $S$ and a subset $X \\subset S$, answers the question whether some element $s \\in S$ is in $X$.\n\nThe main difference between this and standard data structures using sets and lists is in the fact that this is a probabilistic data structure. Specifically, it can return False Positives but never False Negatives.\n\n|           | Positive      | Negative\n|-----------|---------------|---------\n| **True**  | Always        | Always\n| **False** | Probabilistic | Never\n\nA standard implementation of _Bloom Filters_ support adding elements to $X$ but does not support removal requiring the application to reconstruct the data structure accordingly.\n\n_Bloom Filter_ provides a more efficient memory usage than most other constructs such as lists and sets in the cost of a chance for False Positives.\n\nTo illustrate, consider the following interface\n\n```c#\ninterface BloomFilter<S> {\n    // Add {element} to the container\n    void add(S element);\n\n    // Determines whether {element} is in the container\n    bool contains(S element);\n}\n```\n\n## Implementation\n\n- Set __A__ to be an $m$ bits bit array.\n- Set __H__ to be a set of $k$ functions mapping $S$ onto $\\\\{1, 2, ..., m \\\\}$\n\n__add(x)__\n\nApply all hash functions of $H$ on $x$ and set the corresponding bit in $A$ to 1.\n\n- $\\forall h \\in H$  \n  - $A[h(x)] \\leftarrow 1$\n\n__contains(x)__\n\nApply all hash functions of $H$ on $x$ and return true if and only if all of the corresponding bits in $A$ are set to 1.\n\n- $\\forall h \\in H$\n  - $A[h(x)] = 1 \\Rightarrow True$\n\nNow we can easily understand where the False Positives comes from.\n\n## False Positives\n\nAssume \n\n- $S = \\\\{x_1, x_2, x_3\\\\}$\n- $m=5$\n- $k=2$\n\nWith the hash functions  \n\n- $h_1(x_1)=1 ~~ h_1(x_2)=3 ~~ h_1(x_3)=3$\n- $h_2(x_1)=4 ~~ h_2(x_2)=1 ~~ h_2(x_3)=4$\n\nAnd the scenario of $X = \\\\{x_1, x_2\\\\}$ as shown below\n\n| 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|\n|$x_1, x_2$||$x_2$|$x_1$||\n\nApplying __contains($x_3$)__ will yield a False Positive.\n\nWhat was the chance of that happening?\n\nAssuming equal distribution of the hash functions, the probability that a specific bit is unset after applying $k$ functions on an element is $(1 - \\frac {1}{m})^k \\approx e^{-\\frac{k}{m}}$ for large $m$.\n\nNow we can conclude that after the addition of $n$ elements (using __add(x)__) to the data structure the probability for a specific bit to be unset is $e^{-\\frac{kn}{m}}$ and for it to be set is $1 - e^{-\\frac{kn}{m}}$.\n\nFor the containment check to return true it is enough for $k$ specific bits to be set. From the above, the probability for this is $(1 - e^{-\\frac{kn}{m}})^k$.\n\n__To summarize, the probability for a _False Positive_ is $(1 - e^{-\\frac{kn}{m}})^k$.__\n\n## Picking the hash functions\n\n[This paper](https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf) describes a technique of constructing a set of $k$ hash functions based upon exactly 2 hash functions $h_1$ and $h_2$.\n\nThe usefulness of this approach relies in the fact that not all scenarios require the same number of hash functions $k$. Thus, allowing us to provide only 2 base functions $h_1$ and $h_2$ and construct a set of hash functions for any arbitrary $k$.\n\nThere they describe a partitioning of the bit array, each partition of a primary size $p$, such that each hash function maps to $\\\\{ 1, 2, ..., p \\\\}$ within it's own unique partition. (Note that this is just a restatement of the original view).\n\nNow, forall $i$ we can have\n$$\n    g_i(x) = h_1(x) + ih_2(x) \\mod p\n$$\n\n> The paper discusses a lot more and more in-depth","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <nav class=\"toc\">\n      <ol class=\"toc-level toc-level-1\">\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#summary\">Summary</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#implementation\">Implementation</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#false-positives\">False Positives</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#picking-the-hash-functions\">Picking the hash functions</a></li>\n      </ol>\n    </nav>\n    <h2 id=\"summary\">Summary</h2>\n    <p>A <em>Bloom Filter</em> is an data structure that given a set of elements $S$ and a subset $X \\subset S$, answers the question whether some element $s \\in S$ is in $X$.</p>\n    <p>The main difference between this and standard data structures using sets and lists is in the fact that this is a probabilistic data structure. Specifically, it can return False Positives but never False Negatives.</p>\n    <div class=\"table-container\">\n      <table>\n        <thead>\n          <tr>\n            <th></th>\n            <th>Positive</th>\n            <th>Negative</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td><strong>True</strong></td>\n            <td>Always</td>\n            <td>Always</td>\n          </tr>\n          <tr>\n            <td><strong>False</strong></td>\n            <td>Probabilistic</td>\n            <td>Never</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    <p>A standard implementation of <em>Bloom Filters</em> support adding elements to $X$ but does not support removal requiring the application to reconstruct the data structure accordingly.</p>\n    <p><em>Bloom Filter</em> provides a more efficient memory usage than most other constructs such as lists and sets in the cost of a chance for False Positives.</p>\n    <p>To illustrate, consider the following interface</p>\n    <pre><code class=\"hljs language-c#\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">BloomFilter</span>&#x3C;<span class=\"hljs-title\">S</span>> {\n    <span class=\"hljs-comment\">// Add {element} to the container</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">S element</span>)</span>;\n\n    <span class=\"hljs-comment\">// Determines whether {element} is in the container</span>\n    <span class=\"hljs-function\"><span class=\"hljs-built_in\">bool</span> <span class=\"hljs-title\">contains</span>(<span class=\"hljs-params\">S element</span>)</span>;\n}\n</code></pre>\n    <h2 id=\"implementation\">Implementation</h2>\n    <ul>\n      <li>Set <strong>A</strong> to be an $m$ bits bit array.</li>\n      <li>Set <strong>H</strong> to be a set of $k$ functions mapping $S$ onto $\\{1, 2, ..., m \\}$</li>\n    </ul>\n    <p><strong>add(x)</strong></p>\n    <p>Apply all hash functions of $H$ on $x$ and set the corresponding bit in $A$ to 1.</p>\n    <ul>\n      <li>$\\forall h \\in H$\n        <ul>\n          <li>$A[h(x)] \\leftarrow 1$</li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>contains(x)</strong></p>\n    <p>Apply all hash functions of $H$ on $x$ and return true if and only if all of the corresponding bits in $A$ are set to 1.</p>\n    <ul>\n      <li>$\\forall h \\in H$\n        <ul>\n          <li>$A[h(x)] = 1 \\Rightarrow True$</li>\n        </ul>\n      </li>\n    </ul>\n    <p>Now we can easily understand where the False Positives comes from.</p>\n    <h2 id=\"false-positives\">False Positives</h2>\n    <p>Assume</p>\n    <ul>\n      <li>$S = \\{x_1, x_2, x_3\\}$</li>\n      <li>$m=5$</li>\n      <li>$k=2$</li>\n    </ul>\n    <p>With the hash functions</p>\n    <ul>\n      <li>$h_1(x_1)=1 ~~ h_1(x_2)=3 ~~ h_1(x_3)=3$</li>\n      <li>$h_2(x_1)=4 ~~ h_2(x_2)=1 ~~ h_2(x_3)=4$</li>\n    </ul>\n    <p>And the scenario of $X = \\{x_1, x_2\\}$ as shown below</p>\n    <div class=\"table-container\">\n      <table>\n        <thead>\n          <tr>\n            <th align=\"center\">1</th>\n            <th align=\"center\">2</th>\n            <th align=\"center\">3</th>\n            <th align=\"center\">4</th>\n            <th align=\"center\">5</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr>\n            <td align=\"center\">$x_1, x_2$</td>\n            <td align=\"center\"></td>\n            <td align=\"center\">$x_2$</td>\n            <td align=\"center\">$x_1$</td>\n            <td align=\"center\"></td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    <p>Applying <strong>contains($x_3$)</strong> will yield a False Positive.</p>\n    <p>What was the chance of that happening?</p>\n    <p>Assuming equal distribution of the hash functions, the probability that a specific bit is unset after applying $k$ functions on an element is $(1 - \\frac {1}{m})^k \\approx e^{-\\frac{k}{m}}$ for large $m$.</p>\n    <p>Now we can conclude that after the addition of $n$ elements (using <strong>add(x)</strong>) to the data structure the probability for a specific bit to be unset is $e^{-\\frac{kn}{m}}$ and for it to be set is $1 - e^{-\\frac{kn}{m}}$.</p>\n    <p>For the containment check to return true it is enough for $k$ specific bits to be set. From the above, the probability for this is $(1 - e^{-\\frac{kn}{m}})^k$.</p>\n    <p><strong>To summarize, the probability for a <em>False Positive</em> is $(1 - e^{-\\frac{kn}{m}})^k$.</strong></p>\n    <h2 id=\"picking-the-hash-functions\">Picking the hash functions</h2>\n    <p><a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">This paper</a> describes a technique of constructing a set of $k$ hash functions based upon exactly 2 hash functions $h_1$ and $h_2$.</p>\n    <p>The usefulness of this approach relies in the fact that not all scenarios require the same number of hash functions $k$. Thus, allowing us to provide only 2 base functions $h_1$ and $h_2$ and construct a set of hash functions for any arbitrary $k$.</p>\n    <p>There they describe a partitioning of the bit array, each partition of a primary size $p$, such that each hash function maps to $\\{ 1, 2, ..., p \\}$ within it's own unique partition. (Note that this is just a restatement of the original view).</p>\n    <p>\n      Now, forall $i$ we can have\n      $$\n      g_i(x) = h_1(x) + ih_2(x) \\mod p\n      $$\n    </p>\n    <blockquote>\n      <p>The paper discusses a lot more and more in-depth</p>\n    </blockquote>\n  </body>\n</html>\n"}}},"__N_SSG":true}