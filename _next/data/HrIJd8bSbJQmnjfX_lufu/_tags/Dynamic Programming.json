{"pageProps":{"tag":"Dynamic Programming","articles":[{"id":"algorithms/dynamic-programming/longest-increasing-subsequence","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-increasing-subsequence.md","metadata":{"title":"Longest increasing subsequence","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming"],"categories":["Algorithms"]},"content":{"raw":"\n\n**The problem**\n\nGiven a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing\n\n**Illustration**\n\n- [1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]\n- [1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]\n\n**Solution**\n\nlet $(a_i)_{i=1}^n = N$.\n\n$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.\n\nWe can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.\n\nWe shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.\n\nTrivially,\n$$\nopt(0) = 0\n$$\n\nRecursively,\n$$\n\\forall i > 0; ~ opt(i) = 1 + \\max \\\\{ \\\\{0\\\\} \\cup \\\\{ opt(j) | j < i \\land a_j < a_i \\\\} \\\\}\n$$\n\n**Psuedo**\n\n- Initialize opt\n  - $opt \\leftarrow array(n+1)$\n  - $opt[0] \\leftarrow 0$\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n- Return the final answer\n  - $ans \\leftarrow 0$\n  - $for ~ i = 1, 2, ... n$\n    - $ans \\leftarrow max \\\\{ ans, opt[i] \\\\}$\n  - Return $ans$\n\n\n**Time Complexity**\n\n- Initialization of opt is $O(1)$ (single access to opt)\n  - We exclude the actual array creation\n- Building opt takes $O(n)$ iterations\n  - Each iteration takes $O(n)$ accesses at the worst case\n\nSo in total, the time complexity is $O(n^2)$\n\n**Finding the subsequence using a Journal**\n\nWe will keep another data structure $S$ that will act as the journal.\n\nFor each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.\n\nWe can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n    - $S[i] = $ the $j$ that achieved the max\n\nFinally, to print we shall go back from the position of the result using the indices at the journal. \n\n**Finding the subsequence using Traceback**\n\nLets review an example.\n\nAssume $N=[3, 4, 2, 7, 5]$\n\nThe final tabulation of opt will be\n\ni|0|1|2|3|4|5\n-|-|-|-|-|-|-\n$a_i$| |3|4|2|7|5\nopt(i)|0|1|2|1|3|2\n\nHere, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically\n- $opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$\n\nGenerally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j < a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0. \n\n**Actual Code**\n\n{{<codepen RwVdYyO>}}","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p><strong>The problem</strong></p>\n    <p>Given a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing</p>\n    <p><strong>Illustration</strong></p>\n    <ul>\n      <li>[1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]</li>\n      <li>[1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]</li>\n    </ul>\n    <p><strong>Solution</strong></p>\n    <p>let $(a_i)_{i=1}^n = N$.</p>\n    <p>$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.</p>\n    <p>We can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.</p>\n    <p>We shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.</p>\n    <p>\n      Trivially,\n      $$\n      opt(0) = 0\n      $$\n    </p>\n    <p>\n      Recursively,\n      $$\n      \\forall i > 0; ~ opt(i) = 1 + \\max \\{ \\{0\\} \\cup \\{ opt(j) | j &#x3C; i \\land a_j &#x3C; a_i \\} \\}\n      $$\n    </p>\n    <p><strong>Psuedo</strong></p>\n    <ul>\n      <li>\n        <p>Initialize opt</p>\n        <ul>\n          <li>$opt \\leftarrow array(n+1)$</li>\n          <li>$opt[0] \\leftarrow 0$</li>\n        </ul>\n      </li>\n      <li>\n        <p>Build opt in a bottom up fashion</p>\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Return the final answer</p>\n        <ul>\n          <li>$ans \\leftarrow 0$</li>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$ans \\leftarrow max \\{ ans, opt[i] \\}$</li>\n            </ul>\n          </li>\n          <li>Return $ans$</li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(1)$ (single access to opt)\n        <ul>\n          <li>We exclude the actual array creation</li>\n        </ul>\n      </li>\n      <li>Building opt takes $O(n)$ iterations\n        <ul>\n          <li>Each iteration takes $O(n)$ accesses at the worst case</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n    <p><strong>Finding the subsequence using a Journal</strong></p>\n    <p>We will keep another data structure $S$ that will act as the journal.</p>\n    <p>For each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.</p>\n    <p>We can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be</p>\n    <ul>\n      <li>Build opt in a bottom up fashion\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n              <li>$S[i] = $ the $j$ that achieved the max</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n    <p>Finally, to print we shall go back from the position of the result using the indices at the journal.</p>\n    <p><strong>Finding the subsequence using Traceback</strong></p>\n    <p>Lets review an example.</p>\n    <p>Assume $N=[3, 4, 2, 7, 5]$</p>\n    <p>The final tabulation of opt will be</p>\n    <table>\n      <thead>\n        <tr>\n          <th>i</th>\n          <th>0</th>\n          <th>1</th>\n          <th>2</th>\n          <th>3</th>\n          <th>4</th>\n          <th>5</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>$a_i$</td>\n          <td></td>\n          <td>3</td>\n          <td>4</td>\n          <td>2</td>\n          <td>7</td>\n          <td>5</td>\n        </tr>\n        <tr>\n          <td>opt(i)</td>\n          <td>0</td>\n          <td>1</td>\n          <td>2</td>\n          <td>1</td>\n          <td>3</td>\n          <td>2</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>Here, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically</p>\n    <ul>\n      <li>$opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$</li>\n    </ul>\n    <p>Generally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j &#x3C; a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0.</p>\n    <p><strong>Actual Code</strong></p>\n    <p>{{}}</p>\n  </body>\n</html>\n"}},{"id":"algorithms/dynamic-programming/longest-path-in-ordered-graph","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-path-in-ordered-graph.md","metadata":{"title":"Longest Path in Ordered Graph","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming"],"categories":["Algorithms"]},"content":{"raw":"\nA directed graph $G=(V, E)$ is **ordererd**  \n\nif\n$$\n  \\forall (v_i, v_j) \\in E \\Rightarrow i < j\n$$\n\nand\n$$\n  \\forall v_i \\in V / \\\\{ v_n \\\\} ~;~ \\exists j>i, e=(v_i, v_j) \\in E\n$$\n\n**The problem**\n\nGiven such graph, find the length of the longest path from $v_1$ to $v_n$ where $n = |V|$.\n\n**Illustration**\n\n{{< mermaid >}}\n  graph LR\n    v1 --> v2\n    v3 --> v4\n    v4 --> v5\n    v1 --> v4\n    v2 --> v4\n    v2 --> v5\n{{</ mermaid >}}\n\nFor this example, the longest path is $(v_1, v_2) \\rightarrow (v_2, v_4) \\rightarrow (v_4, v_5)$.\n\n**Solution**\n\nWe shall define $opt(i)$ to indicate the length of the longest path from $v_1$ to $v_i$ by\n\n$$\n  opt(0) = 0\n$$\n\n$$\n  opt(i)_{1 > 0} = 1 + \\max \\\\{ opt(k) | (v_k, v_i) \\in E \\\\}\n$$\n\nThe answer we are looking for is given by $opt(n)$.\n\nThe intuition here is breaking the problem into smaller subproblems. The most straight forward way of doing so is by starting from $v_1$ and incrementally adding more vertices into consideration.\n\n**Psuedo**\n\nAs always, pseudo is very important in dynamic programming algorithms in order to illustrate pattenr of building the data structure (bottom up).\n\n- Initialize opt\n  - $opt \\leftarrow array(n)$\n  - $opt[0] \\leftarrow 0$\n  - $\\forall i \\in \\\\{ 1, 2, ..., n \\\\}$\n    - $opt[i] \\leftarrow nil$\n- Build opt in a bottom up fashion\n  - $for ~ i \\leftarrow 1 ~ to ~ n$\n    - $opt[i] \\leftarrow 1 + \\max \\\\{ opt(k) | (v_k, v_i) \\in E \\\\}$\n- Return $opt[n]$\n\n**Time Complexity**\n\n- Initialization of opt is $O(n)$\n- Building opt takes $O(n)$ iterations\n  - Each iteration takes $O(n)$ accesses to opt\n\nSo in total, the time complexity is $O(n^2)$","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p>A directed graph $G=(V, E)$ is <strong>ordererd</strong></p>\n    <p>\n      if\n      $$\n      \\forall (v_i, v_j) \\in E \\Rightarrow i &#x3C; j\n      $$\n    </p>\n    <p>\n      and\n      $$\n      \\forall v_i \\in V / \\{ v_n \\} <del>;</del> \\exists j>i, e=(v_i, v_j) \\in E\n      $$\n    </p>\n    <p><strong>The problem</strong></p>\n    <p>Given such graph, find the length of the longest path from $v_1$ to $v_n$ where $n = |V|$.</p>\n    <p><strong>Illustration</strong></p>\n    <p>\n      {{&#x3C; mermaid >}}\n      graph LR\n      v1 --> v2\n      v3 --> v4\n      v4 --> v5\n      v1 --> v4\n      v2 --> v4\n      v2 --> v5\n      {{&#x3C;/ mermaid >}}\n    </p>\n    <p>For this example, the longest path is $(v_1, v_2) \\rightarrow (v_2, v_4) \\rightarrow (v_4, v_5)$.</p>\n    <p><strong>Solution</strong></p>\n    <p>We shall define $opt(i)$ to indicate the length of the longest path from $v_1$ to $v_i$ by</p>\n    <p>\n      $$\n      opt(0) = 0\n      $$\n    </p>\n    <p>\n      $$\n      opt(i)_{1 > 0} = 1 + \\max \\{ opt(k) | (v_k, v_i) \\in E \\}\n      $$\n    </p>\n    <p>The answer we are looking for is given by $opt(n)$.</p>\n    <p>The intuition here is breaking the problem into smaller subproblems. The most straight forward way of doing so is by starting from $v_1$ and incrementally adding more vertices into consideration.</p>\n    <p><strong>Psuedo</strong></p>\n    <p>As always, pseudo is very important in dynamic programming algorithms in order to illustrate pattenr of building the data structure (bottom up).</p>\n    <ul>\n      <li>Initialize opt\n        <ul>\n          <li>$opt \\leftarrow array(n)$</li>\n          <li>$opt[0] \\leftarrow 0$</li>\n          <li>$\\forall i \\in \\{ 1, 2, ..., n \\}$\n            <ul>\n              <li>$opt[i] \\leftarrow nil$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Build opt in a bottom up fashion\n        <ul>\n          <li>$for ~ i \\leftarrow 1 ~ to ~ n$\n            <ul>\n              <li>$opt[i] \\leftarrow 1 + \\max \\{ opt(k) | (v_k, v_i) \\in E \\}$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Return $opt[n]$</li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(n)$</li>\n      <li>Building opt takes $O(n)$ iterations\n        <ul>\n          <li>Each iteration takes $O(n)$ accesses to opt</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n  </body>\n</html>\n"}},{"id":"algorithms/dynamic-programming/longest-substring-that-is-a-palindrom","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-substring-that-is-a-palindrom.md","metadata":{"title":"Longest substring that is a Palindrom","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming","Palindrom"],"categories":["Algorithms"]},"content":{"raw":"\n# Overview\n\nA string $S$ is a palindrom iff $S = reverse(S)$\n\n**The Problem**\n\nGiven a string S, find the longest *substring* of S that is also a palindrom\n\n> Remember that substrings are consequtive\n\n**To illustrate**\n\n- a**bcb**ea $\\rightarrow$ bcb (not abcba)\n- **abbcbba**dad $\\rightarrow$ abbcbba\n\n# Solution\n\nWe shall define $opt(i, j)$ to indicate the length of the longest palindrom substring between the i'th character to the j'th character by the recurrence relation\n\nfor all i, opt(i, i) = true since a single character is a palindrom of itself.\n\nfor all i and $j > i$, opt(i, j) true if S[i] = S[j] and also opt(i + 1, j - 1) = true.\n\nFinally, to figure out the length of the longest substring that is a palindrom we need to find i and j that maximizes $j - i$ and such that opt(i, j) = true.\n\n**Psuedo**\n\n- Initialize opt\n  - $opt \\leftarrow matrix(n, n)$\n    - initialize all values false by default\n    - $\\forall i$\n      - $opt(i, i) = true$\n      - $opt(i, i + 1) \\leftarrow S[i]=S[i+1]$\n\n- Build opt in a bottom up fashion\n  - $for ~ l = 2, 3, ... n - 1$\n    - $for ~ i = 1, ..., n - l$\n      - $j \\leftarrow i +  - 1$\n      - $opt(i, j) \\leftarrow S[i] = S[j] \\land opt(i + 1, j - 1)$\n- Find the length of the longest substring that is a palindrom\n  - $for~ l = n-1, n-2, ..., 1$\n    - $for~ i = 1, 2, ..., n - l$\n      - $if~ opt(i, i + l)$\n        - return l\n\n**Time Complexity**\n\n- Initialization of opt is $O(n^2)$\n- Building opt takes $O(n^2)$ iterations\n  - Each iteration takes $O(1)$ accesses to opt\n\nSo in total, the time complexity is $O(n^2)$","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <h1>Overview</h1>\n    <p>A string $S$ is a palindrom iff $S = reverse(S)$</p>\n    <p><strong>The Problem</strong></p>\n    <p>Given a string S, find the longest <em>substring</em> of S that is also a palindrom</p>\n    <blockquote>\n      <p>Remember that substrings are consequtive</p>\n    </blockquote>\n    <p><strong>To illustrate</strong></p>\n    <ul>\n      <li>a<strong>bcb</strong>ea $\\rightarrow$ bcb (not abcba)</li>\n      <li><strong>abbcbba</strong>dad $\\rightarrow$ abbcbba</li>\n    </ul>\n    <h1>Solution</h1>\n    <p>We shall define $opt(i, j)$ to indicate the length of the longest palindrom substring between the i'th character to the j'th character by the recurrence relation</p>\n    <p>for all i, opt(i, i) = true since a single character is a palindrom of itself.</p>\n    <p>for all i and $j > i$, opt(i, j) true if S[i] = S[j] and also opt(i + 1, j - 1) = true.</p>\n    <p>Finally, to figure out the length of the longest substring that is a palindrom we need to find i and j that maximizes $j - i$ and such that opt(i, j) = true.</p>\n    <p><strong>Psuedo</strong></p>\n    <ul>\n      <li>\n        <p>Initialize opt</p>\n        <ul>\n          <li>$opt \\leftarrow matrix(n, n)$\n            <ul>\n              <li>initialize all values false by default</li>\n              <li>$\\forall i$\n                <ul>\n                  <li>$opt(i, i) = true$</li>\n                  <li>$opt(i, i + 1) \\leftarrow S[i]=S[i+1]$</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Build opt in a bottom up fashion</p>\n        <ul>\n          <li>$for ~ l = 2, 3, ... n - 1$\n            <ul>\n              <li>$for ~ i = 1, ..., n - l$\n                <ul>\n                  <li>$j \\leftarrow i + - 1$</li>\n                  <li>$opt(i, j) \\leftarrow S[i] = S[j] \\land opt(i + 1, j - 1)$</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Find the length of the longest substring that is a palindrom</p>\n        <ul>\n          <li>$for~ l = n-1, n-2, ..., 1$\n            <ul>\n              <li>$for~ i = 1, 2, ..., n - l$\n                <ul>\n                  <li>$if~ opt(i, i + l)$\n                    <ul>\n                      <li>return l</li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(n^2)$</li>\n      <li>Building opt takes $O(n^2)$ iterations\n        <ul>\n          <li>Each iteration takes $O(1)$ accesses to opt</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n  </body>\n</html>\n"}}]},"__N_SSG":true}