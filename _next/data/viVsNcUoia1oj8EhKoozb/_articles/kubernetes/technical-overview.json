{"pageProps":{"article":{"id":"kubernetes/technical-overview","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/kubernetes/technical-overview.md","metadata":{"title":"Kubernetes technical overview","description":null,"priority":0,"tags":["Kubernetes"],"categories":["Kubernetes"],"toc":true},"content":{"raw":"\n## Application packaging\n\nAn application should be\n\n1. Packaged as a container\n1. Wrapped in a _Pod_\n1. Deployed via a declerative manifest file\n\n## The declerative model \n\nAccording to the _declerative model_, we only declare about how we want the application to look like. It is Kubernetes' jpb to make sure the cluster behaves as intended.\n\n_Manifests_ simple YAML files and they tell Kubernetes how the application should look like - the _desired state_.\n\n_Controllers_ are constantly running and monitor the application's state, reconciling and difference betweeen the _observerd state_ and the _desired state_.\n\n## Pods\n\nIn Kubernetes, _Pods_ are the atomic unit of scheduling. Kubernetes demands that every container runs inside a pod.\n\nA simple model is to run a sigle container in every pod. \n\nEffectively, a _Pod_ is a construct for running one or more containers.\n\nPods are the most basic unit of scaling. We scale applications by adding or removing pods (not containers).\n\nPods are deployed atomiclly. A pod is ready only when all containers are up and running. A single pod executes on a single Node.\n\nWhen a pod dies, a new one takes it's place. The new pod is a different instance with the same semantics, it has different id, ip etc..\n\nPods are immutable. If we want to change a pod's configuration, we must create a new pod to take it's place.\n\n### Pod theory\n\nThere are 3 main reasons for Pods to exist\n\n1. Pods augment containers 1. Pods assist in scheduling\n1. Pods enable resource sharing\n\nThe augmentation is done in the following ways\n\n- Labels / annotations\n- Restart policies\n- Probes (startup, readiness, liveness etc...)\n- Affinity / anti-affinity rules (Affinities are related to specifying how specific pods behave with other pods)\n- Termination control\n- Security policies\n- Resource requests and limits (min/max values on CPU, memory and I/O)\n\nPods have __Labels__ which lets us group Pods and associate them with other objects. \n\nRegarding resource sharing, Pods provide _shared execution environment_ for one or more containers. It includes\n\n- Filesystem\n- Network stack (IP address, routing, ports)\n- Memory\n- Volumes\n\nPods can be deployed either directly via a Pod manifest or indirectly via a controller. Pods deployed directly are called _static pods_.\n\n## Deployments\n\nA _Deployment_ is a higher-level controller. Usually we will deploy pods indirectly via a deployment.\n\nThe deployment controller monitors the state of a wrapped pod providing extra features such as self-healing, scaling, zero-downtime rollouts and versioned rollbacks.\n\n## Services\n\nA _Service_ is a Kubernetes contstruct which provides reliable networking for a set of pods.\n\nAs we know, pods are immutable and modifications due to auto scaling, rollbacks etc... result in replacements of pods - and the effective IPs.\n\n_Services_ provide reliable names and IPs and provide load balancing capabilities over a set of pods.\n\n## Examples of controllers\n\n- Deployments\n- DaemonSets\n- StatefulSets\n\n## Generall usefull commands\n\nList all possible Pod attributes\n\n    kubectl explain pods --recursive\n\n## Multi container patterns\n\nKubernetes offers several well-defined multi-container Pod patterns\n\n### Sidecar pattern\n\nThis pattern has a _main_ application container and a _sidecar_ container. The _sidecar's_ job is to augment and perform secondary tasks for the _main_ application container.\n\n### Adapter pattern\n\nThis pattern is a specific variation of the _sidecar pattern_ where the _sidecar_ container takes non-standardized output from the _main_ container and standardize it as required by an external system.\n\n### Ambassador pattern\n\nThis is another variation of the _sidecar pattern_ where the _sidecar_ brokers connectivity to an external system.\n\n### Init pattern\n\nThis pattern has an _init_ container that's gauranteed to start and complete before your _main_ application container. It is also gauranteed to run exactly once!\n","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <nav class=\"toc\">\n      <ol class=\"toc-level toc-level-1\">\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#application-packaging\">Application packaging</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#the-declerative-model\">The declerative model</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#pods\">Pods</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#deployments\">Deployments</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#services\">Services</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#examples-of-controllers\">Examples of controllers</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#generall-usefull-commands\">Generall usefull commands</a></li>\n        <li class=\"toc-item toc-item-h2\"><a class=\"toc-link toc-link-h2\" href=\"#multi-container-patterns\">Multi container patterns</a></li>\n      </ol>\n    </nav>\n    <h2 id=\"application-packaging\">Application packaging</h2>\n    <p>An application should be</p>\n    <ol>\n      <li>Packaged as a container</li>\n      <li>Wrapped in a <em>Pod</em></li>\n      <li>Deployed via a declerative manifest file</li>\n    </ol>\n    <h2 id=\"the-declerative-model\">The declerative model</h2>\n    <p>According to the <em>declerative model</em>, we only declare about how we want the application to look like. It is Kubernetes' jpb to make sure the cluster behaves as intended.</p>\n    <p><em>Manifests</em> simple YAML files and they tell Kubernetes how the application should look like - the <em>desired state</em>.</p>\n    <p><em>Controllers</em> are constantly running and monitor the application's state, reconciling and difference betweeen the <em>observerd state</em> and the <em>desired state</em>.</p>\n    <h2 id=\"pods\">Pods</h2>\n    <p>In Kubernetes, <em>Pods</em> are the atomic unit of scheduling. Kubernetes demands that every container runs inside a pod.</p>\n    <p>A simple model is to run a sigle container in every pod.</p>\n    <p>Effectively, a <em>Pod</em> is a construct for running one or more containers.</p>\n    <p>Pods are the most basic unit of scaling. We scale applications by adding or removing pods (not containers).</p>\n    <p>Pods are deployed atomiclly. A pod is ready only when all containers are up and running. A single pod executes on a single Node.</p>\n    <p>When a pod dies, a new one takes it's place. The new pod is a different instance with the same semantics, it has different id, ip etc..</p>\n    <p>Pods are immutable. If we want to change a pod's configuration, we must create a new pod to take it's place.</p>\n    <h3 id=\"pod-theory\">Pod theory</h3>\n    <p>There are 3 main reasons for Pods to exist</p>\n    <ol>\n      <li>Pods augment containers 1. Pods assist in scheduling</li>\n      <li>Pods enable resource sharing</li>\n    </ol>\n    <p>The augmentation is done in the following ways</p>\n    <ul>\n      <li>Labels / annotations</li>\n      <li>Restart policies</li>\n      <li>Probes (startup, readiness, liveness etc...)</li>\n      <li>Affinity / anti-affinity rules (Affinities are related to specifying how specific pods behave with other pods)</li>\n      <li>Termination control</li>\n      <li>Security policies</li>\n      <li>Resource requests and limits (min/max values on CPU, memory and I/O)</li>\n    </ul>\n    <p>Pods have <strong>Labels</strong> which lets us group Pods and associate them with other objects.</p>\n    <p>Regarding resource sharing, Pods provide <em>shared execution environment</em> for one or more containers. It includes</p>\n    <ul>\n      <li>Filesystem</li>\n      <li>Network stack (IP address, routing, ports)</li>\n      <li>Memory</li>\n      <li>Volumes</li>\n    </ul>\n    <p>Pods can be deployed either directly via a Pod manifest or indirectly via a controller. Pods deployed directly are called <em>static pods</em>.</p>\n    <h2 id=\"deployments\">Deployments</h2>\n    <p>A <em>Deployment</em> is a higher-level controller. Usually we will deploy pods indirectly via a deployment.</p>\n    <p>The deployment controller monitors the state of a wrapped pod providing extra features such as self-healing, scaling, zero-downtime rollouts and versioned rollbacks.</p>\n    <h2 id=\"services\">Services</h2>\n    <p>A <em>Service</em> is a Kubernetes contstruct which provides reliable networking for a set of pods.</p>\n    <p>As we know, pods are immutable and modifications due to auto scaling, rollbacks etc... result in replacements of pods - and the effective IPs.</p>\n    <p><em>Services</em> provide reliable names and IPs and provide load balancing capabilities over a set of pods.</p>\n    <h2 id=\"examples-of-controllers\">Examples of controllers</h2>\n    <ul>\n      <li>Deployments</li>\n      <li>DaemonSets</li>\n      <li>StatefulSets</li>\n    </ul>\n    <h2 id=\"generall-usefull-commands\">Generall usefull commands</h2>\n    <p>List all possible Pod attributes</p>\n    <pre><code class=\"hljs language-pgsql\">kubectl <span class=\"hljs-keyword\">explain</span> pods <span class=\"hljs-comment\">--recursive</span>\n</code></pre>\n    <h2 id=\"multi-container-patterns\">Multi container patterns</h2>\n    <p>Kubernetes offers several well-defined multi-container Pod patterns</p>\n    <h3 id=\"sidecar-pattern\">Sidecar pattern</h3>\n    <p>This pattern has a <em>main</em> application container and a <em>sidecar</em> container. The <em>sidecar's</em> job is to augment and perform secondary tasks for the <em>main</em> application container.</p>\n    <h3 id=\"adapter-pattern\">Adapter pattern</h3>\n    <p>This pattern is a specific variation of the <em>sidecar pattern</em> where the <em>sidecar</em> container takes non-standardized output from the <em>main</em> container and standardize it as required by an external system.</p>\n    <h3 id=\"ambassador-pattern\">Ambassador pattern</h3>\n    <p>This is another variation of the <em>sidecar pattern</em> where the <em>sidecar</em> brokers connectivity to an external system.</p>\n    <h3 id=\"init-pattern\">Init pattern</h3>\n    <p>This pattern has an <em>init</em> container that's gauranteed to start and complete before your <em>main</em> application container. It is also gauranteed to run exactly once!</p>\n  </body>\n</html>\n"}}},"__N_SSG":true}