{"pageProps":{"article":{"id":"intro-to-ai/adversarial-search","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/intro-to-ai/adversarial-search.md","metadata":{"title":"Adversarial Search","description":null,"priority":4,"tags":[],"categories":["Intro to AI"],"toc":false},"content":{"raw":"\nA **competitive environment** is a multi-agent environment in which two or more adversarial agents have coflicting goals. There are multiple ways we can view a such environments, Here we will model adversarial agents with the techniques of adversarial game-tree search. \n\nTo introduce the topic we will restrict ourselves to **Two-player zero-sum games**.\n\n## Two-player zero-sum games\n\nA game is said to be \n\n- _Deterministic_ if every action leads to a deterministic state.\n- With _Perfect Information_ if it's a _fully observable_ environment. Meaning, every player can see the entire state.\n- _Zero-Sum_ when there are zero points alloted to the game at initialization and players gain points by taking them from other players. There is no \"win-win\" situation.\n- _Turn Making_ if only a single player can make a move in each state, alternatively.\n\nA **two-player zero-sum game** is a deterministic, two-player, turn-making, zero-sum game with perfect information.\n\nWe will name the two adversaries **MAX** and **MIN**.\n\nFormally we define the game with the following elements:\n\n- $S_0$ is the **initial state**.\n- _ToMove(s)_ is the player to make the move in state s.\n- _Actions(s)_ is the set of legal moves in state s.\n- _Result(s, a)_ is the **transition model** which defines the resulting state of state s after action a.\n- _IsTerminal(s)_ is the **terminal test** indicating whether s is a terminal state.\n- _Utility(s, p)_ is the **utility function** which defines the value assigned to player p if the game terminated in the terminal state s. This function is also known as **objective function** or **payoff function**\n\nLike many other search problems, $S_0$, _Actions_ and _Result_ define a **state space graph** - A graph where the vertices are states and the edges are the moves. We can impose a **search tree** in order to determine what action to take by searching the graph. We define the complete **game tree** as the tree as the search tree that investigate every possible action for every possible state up to terminals.\n\nTake a look at the example search tree below. Note that by convention we will symbolize the MAX player with a triangle and the MIN player with an inverted triangle.\n\n```plantuml\n\ngraph G {\n\tA [shape=triangle]\n\tB [shape=invtriangle]\n\tC [shape=invtriangle]\n\tD [shape=invtriangle]\n\tE [shape=triangle]\n\tF [shape=triangle]\n\tG [shape=triangle]\n\tH [shape=triangle]\n\tI [shape=triangle]\n\tJ [shape=triangle]\n\tK [shape=triangle]\n\tL [shape=triangle]\n\tM [shape=triangle]\n\n\tA -- B [label=<a<sub>1</sub>>];\n\tA -- C [label=<a<sub>2</sub>>];\n\tA -- D [label=<a<sub>3</sub>>];\n\n\tB -- E [label=<b<sub>1</sub>>];\n\tB -- F [label=<b<sub>2</sub>>];\n\tB -- G [label=<b<sub>3</sub>>];\n\n\tC -- H [label=<c<sub>1</sub>>];\n\tC -- I [label=<c<sub>2</sub>>];\n\tC -- J [label=<c<sub>3</sub>>];\n\n\tD -- K [label=<d<sub>1</sub>>];\n\tD -- L [label=<d<sub>2</sub>>];\n\tD -- M [label=<d<sub>3</sub>>];\n}\n\n```\n\n## The Minimax search algorithm\n\nBoth MAX and MIN playes aim to optimize their decisions throughout the game. Every action MAX makes MIN also makes an action! MAX cannot hope for MIN to blunder - He needs to find a sequence of actions that will maximize the score assuming MIN tries to minimize the score.\n\nThe search approach we take is to keep track of the score after each decision in the tree. Decisions made by MAX aim to increase the score while decisions made by MIN aim to decrease the score - Practically we will run a DFS variant, tracking and modifying the score accordingly. This algorithm is called **minimax search**.\n\nFormally:\n\n\\begin{align*}\nMinmax(s) =& & \\\\\\\\\n  & Utility(s, MAX) & if ~ IsTerminal(s) \\\\\\\\\n  & \\max_{a \\in Actions(s)}{Minimax(s, a)} & if ~ ToMove(s) = MAX \\\\\\\\\n  & \\min_{a \\in Actions(s)}{Minimax(s, a)} & if ~ ToMove(s) = MAX \\\\\\\\\n\\end{align*}\n\nJust computing the Minimax is not enought. Remember, we needed a search algorithm to tell MAX what is his optimal action to take. For this purpose, we need to keep track of the optimal move when computing the Minimax.\n\n```python\ndef MinimaxSearch(game, state) -> action \\\\\\\\\n  player = game.ToMove(state)\n  value, move = MaxValue(game, state, player)\n  return move\n\ndef MaxValue(game, state, player) -> (utility, action):\n  if game.IsTerminal(state):\n    return game.Utility(state, player), null\n\n  return (utility, action) that maximizes\n    MinValue(game, game.Result(state, a), player) foreach a in Actions(state)\n\ndef MinValue(game, state, player) -> (utility, action):\n  if game.IsTerminal(state):\n    return game.Utility(state, player), null\n\n  return (utility, action) that minimizes \n    MaxValue(game, game.Result(state, a), player) foreach a in Actions(state)\n\n```\n\n## More than 2 agents\n\nTODO\n\n## Alpha-Beta pruning\n\nTODO\n","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p>A <strong>competitive environment</strong> is a multi-agent environment in which two or more adversarial agents have coflicting goals. There are multiple ways we can view a such environments, Here we will model adversarial agents with the techniques of adversarial game-tree search.</p>\n    <p>To introduce the topic we will restrict ourselves to <strong>Two-player zero-sum games</strong>.</p>\n    <h2 id=\"two-player-zero-sum-games\">Two-player zero-sum games</h2>\n    <p>A game is said to be</p>\n    <ul>\n      <li><em>Deterministic</em> if every action leads to a deterministic state.</li>\n      <li>With <em>Perfect Information</em> if it's a <em>fully observable</em> environment. Meaning, every player can see the entire state.</li>\n      <li><em>Zero-Sum</em> when there are zero points alloted to the game at initialization and players gain points by taking them from other players. There is no \"win-win\" situation.</li>\n      <li><em>Turn Making</em> if only a single player can make a move in each state, alternatively.</li>\n    </ul>\n    <p>A <strong>two-player zero-sum game</strong> is a deterministic, two-player, turn-making, zero-sum game with perfect information.</p>\n    <p>We will name the two adversaries <strong>MAX</strong> and <strong>MIN</strong>.</p>\n    <p>Formally we define the game with the following elements:</p>\n    <ul>\n      <li>$S_0$ is the <strong>initial state</strong>.</li>\n      <li><em>ToMove(s)</em> is the player to make the move in state s.</li>\n      <li><em>Actions(s)</em> is the set of legal moves in state s.</li>\n      <li><em>Result(s, a)</em> is the <strong>transition model</strong> which defines the resulting state of state s after action a.</li>\n      <li><em>IsTerminal(s)</em> is the <strong>terminal test</strong> indicating whether s is a terminal state.</li>\n      <li><em>Utility(s, p)</em> is the <strong>utility function</strong> which defines the value assigned to player p if the game terminated in the terminal state s. This function is also known as <strong>objective function</strong> or <strong>payoff function</strong></li>\n    </ul>\n    <p>Like many other search problems, $S_0$, <em>Actions</em> and <em>Result</em> define a <strong>state space graph</strong> - A graph where the vertices are states and the edges are the moves. We can impose a <strong>search tree</strong> in order to determine what action to take by searching the graph. We define the complete <strong>game tree</strong> as the tree as the search tree that investigate every possible action for every possible state up to terminals.</p>\n    <p>Take a look at the example search tree below. Note that by convention we will symbolize the MAX player with a triangle and the MIN player with an inverted triangle.</p>\n    <img src=\"https://www.plantuml.com/plantuml/png/RT3T2e8m6CRnOtSLkm69rc4grFp-k8BmOAkXWeXeTHBTUqxAzDrxDFZpOmyRgGRHrpIYBsATw6MiHQ_S-z28hcfLIQpphpNTSvKvddqy1yZ58T8YfCL8Iv2M8Yr3MewqmcpwDsoRJizlXLIjwmXdV4Xlx-pquPN7B-00C0Xy00v_e7zt4i4YfB4nWn001a44m6Q3Qn4lucfip201W46G0h3PyBN85d4pDcQG0y0WA01ORRp91m00\">\n    <h2 id=\"the-minimax-search-algorithm\">The Minimax search algorithm</h2>\n    <p>Both MAX and MIN playes aim to optimize their decisions throughout the game. Every action MAX makes MIN also makes an action! MAX cannot hope for MIN to blunder - He needs to find a sequence of actions that will maximize the score assuming MIN tries to minimize the score.</p>\n    <p>The search approach we take is to keep track of the score after each decision in the tree. Decisions made by MAX aim to increase the score while decisions made by MIN aim to decrease the score - Practically we will run a DFS variant, tracking and modifying the score accordingly. This algorithm is called <strong>minimax search</strong>.</p>\n    <p>Formally:</p>\n    <p>\n      \\begin{align*}\n      Minmax(s) =&#x26; &#x26; \\\\\n      &#x26; Utility(s, MAX) &#x26; if ~ IsTerminal(s) \\\\\n      &#x26; \\max_{a \\in Actions(s)}{Minimax(s, a)} &#x26; if ~ ToMove(s) = MAX \\\\\n      &#x26; \\min_{a \\in Actions(s)}{Minimax(s, a)} &#x26; if ~ ToMove(s) = MAX \\\\\n      \\end{align*}\n    </p>\n    <p>Just computing the Minimax is not enought. Remember, we needed a search algorithm to tell MAX what is his optimal action to take. For this purpose, we need to keep track of the optimal move when computing the Minimax.</p>\n    <pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">MinimaxSearch</span>(<span class=\"hljs-params\">game, state</span>) -> action \\\\\\\\\n  player = game.ToMove(state)\n  value, move = MaxValue(game, state, player)\n  <span class=\"hljs-keyword\">return</span> move\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">MaxValue</span>(<span class=\"hljs-params\">game, state, player</span>) -> (utility, action):\n  <span class=\"hljs-keyword\">if</span> game.IsTerminal(state):\n    <span class=\"hljs-keyword\">return</span> game.Utility(state, player), null\n\n  <span class=\"hljs-keyword\">return</span> (utility, action) that maximizes\n    MinValue(game, game.Result(state, a), player) foreach a <span class=\"hljs-keyword\">in</span> Actions(state)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">MinValue</span>(<span class=\"hljs-params\">game, state, player</span>) -> (utility, action):\n  <span class=\"hljs-keyword\">if</span> game.IsTerminal(state):\n    <span class=\"hljs-keyword\">return</span> game.Utility(state, player), null\n\n  <span class=\"hljs-keyword\">return</span> (utility, action) that minimizes \n    MaxValue(game, game.Result(state, a), player) foreach a <span class=\"hljs-keyword\">in</span> Actions(state)\n\n</code></pre>\n    <h2 id=\"more-than-2-agents\">More than 2 agents</h2>\n    <p>TODO</p>\n    <h2 id=\"alpha-beta-pruning\">Alpha-Beta pruning</h2>\n    <p>TODO</p>\n  </body>\n</html>\n"}}},"__N_SSG":true}