{"pageProps":{"category":"Algorithms","articles":[{"id":"algorithms/bloom","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/bloom.md","metadata":{"title":"Bloom Filter","description":"Illustrate the Bloomfilter data structure","permalink":null,"priority":0,"tags":[],"categories":["Algorithms"]},"content":{"raw":"\n## Summary\n\nA _Bloom Filter_ is an data structure that given a set of elements $S$ and a subset $X \\subset S$, answers the question whether some element $s \\in S$ is in $X$.\n\nThe main difference between this and standard data structures using sets and lists is in the fact that this is a probabilistic data structure. Specifically, it can return False Positives but never False Negatives.\n\n|           | Positive      | Negative\n|-----------|---------------|---------\n| **True**  | Always        | Always\n| **False** | Probabilistic | Never\n\nA standard implementation of _Bloom Filters_ support adding elements to $X$ but does not support removal requiring the application to reconstruct the data structure accordingly.\n\n_Bloom Filter_ provides a more efficient memory usage than most other constructs such as lists and sets in the cost of a chance for False Positives.\n\nTo illustrate, consider the following interface\n\n```c#\ninterface BloomFilter<S> {\n    // Add {element} to the container\n    void add(S element);\n\n    // Determines whether {element} is in the container\n    bool contains(S element);\n}\n```\n\n## Implementation\n\n- Set __A__ to be an $m$ bits bit array.\n- Set __H__ to be a set of $k$ functions mapping $S$ onto $\\\\{1, 2, ..., m \\\\}$\n\n__add(x)__\n\nApply all hash functions of $H$ on $x$ and set the corresponding bit in $A$ to 1.\n\n- $\\forall h \\in H$  \n  - $A[h(x)] \\leftarrow 1$\n\n__contains(x)__\n\nApply all hash functions of $H$ on $x$ and return true if and only if all of the corresponding bits in $A$ are set to 1.\n\n- $\\forall h \\in H$\n  - $A[h(x)] = 1 \\Rightarrow True$\n\nNow we can easily understand where the False Positives comes from.\n\n## False Positives\n\nAssume \n\n- $S = \\\\{x_1, x_2, x_3\\\\}$\n- $m=5$\n- $k=2$\n\nWith the hash functions  \n\n- $h_1(x_1)=1 ~~ h_1(x_2)=3 ~~ h_1(x_3)=3$\n- $h_2(x_1)=4 ~~ h_2(x_2)=1 ~~ h_2(x_3)=4$\n\nAnd the scenario of $X = \\\\{x_1, x_2\\\\}$ as shown below\n\n| 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|\n|$x_1, x_2$||$x_2$|$x_1$||\n\nApplying __contains($x_3$)__ will yield a False Positive.\n\nWhat was the chance of that happening?\n\nAssuming equal distribution of the hash functions, the probability that a specific bit is unset after applying $k$ functions on an element is $(1 - \\frac {1}{m})^k \\approx e^{-\\frac{k}{m}}$ for large $m$.\n\nNow we can conclude that after the addition of $n$ elements (using __add(x)__) to the data structure the probability for a specific bit to be unset is $e^{-\\frac{kn}{m}}$ and for it to be set is $1 - e^{-\\frac{kn}{m}}$.\n\nFor the containment check to return true it is enough for $k$ specific bits to be set. From the above, the probability for this is $(1 - e^{-\\frac{kn}{m}})^k$.\n\n__To summarize, the probability for a _False Positive_ is $(1 - e^{-\\frac{kn}{m}})^k$.__\n\n## Picking the hash functions\n\n[This paper](https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf) describes a technique of constructing a set of $k$ hash functions based upon exactly 2 hash functions $h_1$ and $h_2$.\n\nThe usefulness of this approach relies in the fact that not all scenarios require the same number of hash functions $k$. Thus, allowing us to provide only 2 base functions $h_1$ and $h_2$ and construct a set of hash functions for any arbitrary $k$.\n\nThere they describe a partitioning of the bit array, each partition of a primary size $p$, such that each hash function maps to $\\\\{ 1, 2, ..., p \\\\}$ within it's own unique partition. (Note that this is just a restatement of the original view).\n\nNow, forall $i$ we can have\n$$\n    g_i(x) = h_1(x) + ih_2(x) \\mod p\n$$\n\n> The paper discusses a lot more and more in-depth","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <h2>Summary</h2>\n    <p>A <em>Bloom Filter</em> is an data structure that given a set of elements $S$ and a subset $X \\subset S$, answers the question whether some element $s \\in S$ is in $X$.</p>\n    <p>The main difference between this and standard data structures using sets and lists is in the fact that this is a probabilistic data structure. Specifically, it can return False Positives but never False Negatives.</p>\n    <table>\n      <thead>\n        <tr>\n          <th></th>\n          <th>Positive</th>\n          <th>Negative</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td><strong>True</strong></td>\n          <td>Always</td>\n          <td>Always</td>\n        </tr>\n        <tr>\n          <td><strong>False</strong></td>\n          <td>Probabilistic</td>\n          <td>Never</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>A standard implementation of <em>Bloom Filters</em> support adding elements to $X$ but does not support removal requiring the application to reconstruct the data structure accordingly.</p>\n    <p><em>Bloom Filter</em> provides a more efficient memory usage than most other constructs such as lists and sets in the cost of a chance for False Positives.</p>\n    <p>To illustrate, consider the following interface</p>\n    <pre><code class=\"hljs language-c#\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">BloomFilter</span>&#x3C;<span class=\"hljs-title\">S</span>> {\n    <span class=\"hljs-comment\">// Add {element} to the container</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span>(<span class=\"hljs-params\">S element</span>)</span>;\n\n    <span class=\"hljs-comment\">// Determines whether {element} is in the container</span>\n    <span class=\"hljs-function\"><span class=\"hljs-built_in\">bool</span> <span class=\"hljs-title\">contains</span>(<span class=\"hljs-params\">S element</span>)</span>;\n}\n</code></pre>\n    <h2>Implementation</h2>\n    <ul>\n      <li>Set <strong>A</strong> to be an $m$ bits bit array.</li>\n      <li>Set <strong>H</strong> to be a set of $k$ functions mapping $S$ onto $\\{1, 2, ..., m \\}$</li>\n    </ul>\n    <p><strong>add(x)</strong></p>\n    <p>Apply all hash functions of $H$ on $x$ and set the corresponding bit in $A$ to 1.</p>\n    <ul>\n      <li>$\\forall h \\in H$\n        <ul>\n          <li>$A[h(x)] \\leftarrow 1$</li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>contains(x)</strong></p>\n    <p>Apply all hash functions of $H$ on $x$ and return true if and only if all of the corresponding bits in $A$ are set to 1.</p>\n    <ul>\n      <li>$\\forall h \\in H$\n        <ul>\n          <li>$A[h(x)] = 1 \\Rightarrow True$</li>\n        </ul>\n      </li>\n    </ul>\n    <p>Now we can easily understand where the False Positives comes from.</p>\n    <h2>False Positives</h2>\n    <p>Assume</p>\n    <ul>\n      <li>$S = \\{x_1, x_2, x_3\\}$</li>\n      <li>$m=5$</li>\n      <li>$k=2$</li>\n    </ul>\n    <p>With the hash functions</p>\n    <ul>\n      <li>$h_1(x_1)=1 ~~ h_1(x_2)=3 ~~ h_1(x_3)=3$</li>\n      <li>$h_2(x_1)=4 ~~ h_2(x_2)=1 ~~ h_2(x_3)=4$</li>\n    </ul>\n    <p>And the scenario of $X = \\{x_1, x_2\\}$ as shown below</p>\n    <table>\n      <thead>\n        <tr>\n          <th align=\"center\">1</th>\n          <th align=\"center\">2</th>\n          <th align=\"center\">3</th>\n          <th align=\"center\">4</th>\n          <th align=\"center\">5</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td align=\"center\">$x_1, x_2$</td>\n          <td align=\"center\"></td>\n          <td align=\"center\">$x_2$</td>\n          <td align=\"center\">$x_1$</td>\n          <td align=\"center\"></td>\n        </tr>\n      </tbody>\n    </table>\n    <p>Applying <strong>contains($x_3$)</strong> will yield a False Positive.</p>\n    <p>What was the chance of that happening?</p>\n    <p>Assuming equal distribution of the hash functions, the probability that a specific bit is unset after applying $k$ functions on an element is $(1 - \\frac {1}{m})^k \\approx e^{-\\frac{k}{m}}$ for large $m$.</p>\n    <p>Now we can conclude that after the addition of $n$ elements (using <strong>add(x)</strong>) to the data structure the probability for a specific bit to be unset is $e^{-\\frac{kn}{m}}$ and for it to be set is $1 - e^{-\\frac{kn}{m}}$.</p>\n    <p>For the containment check to return true it is enough for $k$ specific bits to be set. From the above, the probability for this is $(1 - e^{-\\frac{kn}{m}})^k$.</p>\n    <p><strong>To summarize, the probability for a <em>False Positive</em> is $(1 - e^{-\\frac{kn}{m}})^k$.</strong></p>\n    <h2>Picking the hash functions</h2>\n    <p><a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">This paper</a> describes a technique of constructing a set of $k$ hash functions based upon exactly 2 hash functions $h_1$ and $h_2$.</p>\n    <p>The usefulness of this approach relies in the fact that not all scenarios require the same number of hash functions $k$. Thus, allowing us to provide only 2 base functions $h_1$ and $h_2$ and construct a set of hash functions for any arbitrary $k$.</p>\n    <p>There they describe a partitioning of the bit array, each partition of a primary size $p$, such that each hash function maps to $\\{ 1, 2, ..., p \\}$ within it's own unique partition. (Note that this is just a restatement of the original view).</p>\n    <p>\n      Now, forall $i$ we can have\n      $$\n      g_i(x) = h_1(x) + ih_2(x) \\mod p\n      $$\n    </p>\n    <blockquote>\n      <p>The paper discusses a lot more and more in-depth</p>\n    </blockquote>\n  </body>\n</html>\n"}},{"id":"algorithms/dynamic-programming/longest-increasing-subsequence","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-increasing-subsequence.md","metadata":{"title":"Longest increasing subsequence","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming"],"categories":["Algorithms"]},"content":{"raw":"\n\n**The problem**\n\nGiven a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing\n\n**Illustration**\n\n- [1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]\n- [1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]\n\n**Solution**\n\nlet $(a_i)_{i=1}^n = N$.\n\n$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.\n\nWe can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.\n\nWe shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.\n\nTrivially,\n$$\nopt(0) = 0\n$$\n\nRecursively,\n$$\n\\forall i > 0; ~ opt(i) = 1 + \\max \\\\{ \\\\{0\\\\} \\cup \\\\{ opt(j) | j < i \\land a_j < a_i \\\\} \\\\}\n$$\n\n**Psuedo**\n\n- Initialize opt\n  - $opt \\leftarrow array(n+1)$\n  - $opt[0] \\leftarrow 0$\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n- Return the final answer\n  - $ans \\leftarrow 0$\n  - $for ~ i = 1, 2, ... n$\n    - $ans \\leftarrow max \\\\{ ans, opt[i] \\\\}$\n  - Return $ans$\n\n\n**Time Complexity**\n\n- Initialization of opt is $O(1)$ (single access to opt)\n  - We exclude the actual array creation\n- Building opt takes $O(n)$ iterations\n  - Each iteration takes $O(n)$ accesses at the worst case\n\nSo in total, the time complexity is $O(n^2)$\n\n**Finding the subsequence using a Journal**\n\nWe will keep another data structure $S$ that will act as the journal.\n\nFor each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.\n\nWe can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be\n\n- Build opt in a bottom up fashion\n  - $for ~ i = 1, 2, ... n$\n    - $opt[i] = 1 + \\max_{j < i \\land a_j < a_i}{opt[j]}$\n    - $S[i] = $ the $j$ that achieved the max\n\nFinally, to print we shall go back from the position of the result using the indices at the journal. \n\n**Finding the subsequence using Traceback**\n\nLets review an example.\n\nAssume $N=[3, 4, 2, 7, 5]$\n\nThe final tabulation of opt will be\n\ni|0|1|2|3|4|5\n-|-|-|-|-|-|-\n$a_i$| |3|4|2|7|5\nopt(i)|0|1|2|1|3|2\n\nHere, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically\n- $opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$\n\nGenerally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j < a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0. \n\n**Actual Code**\n\n{{<codepen RwVdYyO>}}","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p><strong>The problem</strong></p>\n    <p>Given a sequence of numbers $N$, find the length of longest subsequence of numbers that is increasing</p>\n    <p><strong>Illustration</strong></p>\n    <ul>\n      <li>[1, 2, 3, 4] $\\rightarrow$ [1, 2, 3, 4]</li>\n      <li>[1, 4, 2, 6, 3, 7] $\\rightarrow$ [1, 4, 6, 7]</li>\n    </ul>\n    <p><strong>Solution</strong></p>\n    <p>let $(a_i)_{i=1}^n = N$.</p>\n    <p>$a_i$ can contribute to a subsequence of previous elements only if it is greater than all those elements.</p>\n    <p>We can also realize the the longest increasing subsequence that ends with $a_i$ is the previous longest subsequence containing elements less that $a_i$, adding $a_i$ to it.</p>\n    <p>We shall define opt(i) to indicate the length of the longest increasing subsequence that ends with $a_i$.</p>\n    <p>\n      Trivially,\n      $$\n      opt(0) = 0\n      $$\n    </p>\n    <p>\n      Recursively,\n      $$\n      \\forall i > 0; ~ opt(i) = 1 + \\max \\{ \\{0\\} \\cup \\{ opt(j) | j &#x3C; i \\land a_j &#x3C; a_i \\} \\}\n      $$\n    </p>\n    <p><strong>Psuedo</strong></p>\n    <ul>\n      <li>\n        <p>Initialize opt</p>\n        <ul>\n          <li>$opt \\leftarrow array(n+1)$</li>\n          <li>$opt[0] \\leftarrow 0$</li>\n        </ul>\n      </li>\n      <li>\n        <p>Build opt in a bottom up fashion</p>\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Return the final answer</p>\n        <ul>\n          <li>$ans \\leftarrow 0$</li>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$ans \\leftarrow max \\{ ans, opt[i] \\}$</li>\n            </ul>\n          </li>\n          <li>Return $ans$</li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(1)$ (single access to opt)\n        <ul>\n          <li>We exclude the actual array creation</li>\n        </ul>\n      </li>\n      <li>Building opt takes $O(n)$ iterations\n        <ul>\n          <li>Each iteration takes $O(n)$ accesses at the worst case</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n    <p><strong>Finding the subsequence using a Journal</strong></p>\n    <p>We will keep another data structure $S$ that will act as the journal.</p>\n    <p>For each $i$, $S$ will contain the index $j$ that contains the previous element in the subsequence.</p>\n    <p>We can fill it during the algorithm by modifying \"Build opt in a bottom up fashion\" to be</p>\n    <ul>\n      <li>Build opt in a bottom up fashion\n        <ul>\n          <li>$for ~ i = 1, 2, ... n$\n            <ul>\n              <li>$opt[i] = 1 + \\max_{j &#x3C; i \\land a_j &#x3C; a_i}{opt[j]}$</li>\n              <li>$S[i] = $ the $j$ that achieved the max</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n    <p>Finally, to print we shall go back from the position of the result using the indices at the journal.</p>\n    <p><strong>Finding the subsequence using Traceback</strong></p>\n    <p>Lets review an example.</p>\n    <p>Assume $N=[3, 4, 2, 7, 5]$</p>\n    <p>The final tabulation of opt will be</p>\n    <table>\n      <thead>\n        <tr>\n          <th>i</th>\n          <th>0</th>\n          <th>1</th>\n          <th>2</th>\n          <th>3</th>\n          <th>4</th>\n          <th>5</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td>$a_i$</td>\n          <td></td>\n          <td>3</td>\n          <td>4</td>\n          <td>2</td>\n          <td>7</td>\n          <td>5</td>\n        </tr>\n        <tr>\n          <td>opt(i)</td>\n          <td>0</td>\n          <td>1</td>\n          <td>2</td>\n          <td>1</td>\n          <td>3</td>\n          <td>2</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>Here, we need to find $7 \\leftarrow 4 \\leftarrow 3$. Specifically</p>\n    <ul>\n      <li>$opt(\"7\") = 3, opt(\"4\") = 2, opt(\"3\") = 1$</li>\n    </ul>\n    <p>Generally, to traceback, we shall find the index i that contains the maximum of opt as we did finding the answer. We notice that the previous element in the relevant subsequence is ending a subsequence of length $opt(i) - 1$. So we traverse back in the opt array until we find an element $a_j$ such that $a_j &#x3C; a_i$ and $opt(j) = opt(i) - 1$. This $j$ is the index of the previous element in the answer. We will keep going in this manner until index 0.</p>\n    <p><strong>Actual Code</strong></p>\n    <p>{{}}</p>\n  </body>\n</html>\n"}},{"id":"algorithms/dynamic-programming/longest-path-in-ordered-graph","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-path-in-ordered-graph.md","metadata":{"title":"Longest Path in Ordered Graph","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming"],"categories":["Algorithms"]},"content":{"raw":"\nA directed graph $G=(V, E)$ is **ordererd**  \n\nif\n$$\n  \\forall (v_i, v_j) \\in E \\Rightarrow i < j\n$$\n\nand\n$$\n  \\forall v_i \\in V / \\\\{ v_n \\\\} ~;~ \\exists j>i, e=(v_i, v_j) \\in E\n$$\n\n**The problem**\n\nGiven such graph, find the length of the longest path from $v_1$ to $v_n$ where $n = |V|$.\n\n**Illustration**\n\n{{< mermaid >}}\n  graph LR\n    v1 --> v2\n    v3 --> v4\n    v4 --> v5\n    v1 --> v4\n    v2 --> v4\n    v2 --> v5\n{{</ mermaid >}}\n\nFor this example, the longest path is $(v_1, v_2) \\rightarrow (v_2, v_4) \\rightarrow (v_4, v_5)$.\n\n**Solution**\n\nWe shall define $opt(i)$ to indicate the length of the longest path from $v_1$ to $v_i$ by\n\n$$\n  opt(0) = 0\n$$\n\n$$\n  opt(i)_{1 > 0} = 1 + \\max \\\\{ opt(k) | (v_k, v_i) \\in E \\\\}\n$$\n\nThe answer we are looking for is given by $opt(n)$.\n\nThe intuition here is breaking the problem into smaller subproblems. The most straight forward way of doing so is by starting from $v_1$ and incrementally adding more vertices into consideration.\n\n**Psuedo**\n\nAs always, pseudo is very important in dynamic programming algorithms in order to illustrate pattenr of building the data structure (bottom up).\n\n- Initialize opt\n  - $opt \\leftarrow array(n)$\n  - $opt[0] \\leftarrow 0$\n  - $\\forall i \\in \\\\{ 1, 2, ..., n \\\\}$\n    - $opt[i] \\leftarrow nil$\n- Build opt in a bottom up fashion\n  - $for ~ i \\leftarrow 1 ~ to ~ n$\n    - $opt[i] \\leftarrow 1 + \\max \\\\{ opt(k) | (v_k, v_i) \\in E \\\\}$\n- Return $opt[n]$\n\n**Time Complexity**\n\n- Initialization of opt is $O(n)$\n- Building opt takes $O(n)$ iterations\n  - Each iteration takes $O(n)$ accesses to opt\n\nSo in total, the time complexity is $O(n^2)$","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <p>A directed graph $G=(V, E)$ is <strong>ordererd</strong></p>\n    <p>\n      if\n      $$\n      \\forall (v_i, v_j) \\in E \\Rightarrow i &#x3C; j\n      $$\n    </p>\n    <p>\n      and\n      $$\n      \\forall v_i \\in V / \\{ v_n \\} <del>;</del> \\exists j>i, e=(v_i, v_j) \\in E\n      $$\n    </p>\n    <p><strong>The problem</strong></p>\n    <p>Given such graph, find the length of the longest path from $v_1$ to $v_n$ where $n = |V|$.</p>\n    <p><strong>Illustration</strong></p>\n    <p>\n      {{&#x3C; mermaid >}}\n      graph LR\n      v1 --> v2\n      v3 --> v4\n      v4 --> v5\n      v1 --> v4\n      v2 --> v4\n      v2 --> v5\n      {{&#x3C;/ mermaid >}}\n    </p>\n    <p>For this example, the longest path is $(v_1, v_2) \\rightarrow (v_2, v_4) \\rightarrow (v_4, v_5)$.</p>\n    <p><strong>Solution</strong></p>\n    <p>We shall define $opt(i)$ to indicate the length of the longest path from $v_1$ to $v_i$ by</p>\n    <p>\n      $$\n      opt(0) = 0\n      $$\n    </p>\n    <p>\n      $$\n      opt(i)_{1 > 0} = 1 + \\max \\{ opt(k) | (v_k, v_i) \\in E \\}\n      $$\n    </p>\n    <p>The answer we are looking for is given by $opt(n)$.</p>\n    <p>The intuition here is breaking the problem into smaller subproblems. The most straight forward way of doing so is by starting from $v_1$ and incrementally adding more vertices into consideration.</p>\n    <p><strong>Psuedo</strong></p>\n    <p>As always, pseudo is very important in dynamic programming algorithms in order to illustrate pattenr of building the data structure (bottom up).</p>\n    <ul>\n      <li>Initialize opt\n        <ul>\n          <li>$opt \\leftarrow array(n)$</li>\n          <li>$opt[0] \\leftarrow 0$</li>\n          <li>$\\forall i \\in \\{ 1, 2, ..., n \\}$\n            <ul>\n              <li>$opt[i] \\leftarrow nil$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Build opt in a bottom up fashion\n        <ul>\n          <li>$for ~ i \\leftarrow 1 ~ to ~ n$\n            <ul>\n              <li>$opt[i] \\leftarrow 1 + \\max \\{ opt(k) | (v_k, v_i) \\in E \\}$</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Return $opt[n]$</li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(n)$</li>\n      <li>Building opt takes $O(n)$ iterations\n        <ul>\n          <li>Each iteration takes $O(n)$ accesses to opt</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n  </body>\n</html>\n"}},{"id":"algorithms/dynamic-programming/longest-substring-that-is-a-palindrom","filePath":"/home/runner/work/tglanz.github.io/tglanz.github.io/content/algorithms/dynamic-programming/longest-substring-that-is-a-palindrom.md","metadata":{"title":"Longest substring that is a Palindrom","description":null,"permalink":null,"priority":0,"tags":["Dynamic Programming","Palindrom"],"categories":["Algorithms"]},"content":{"raw":"\n# Overview\n\nA string $S$ is a palindrom iff $S = reverse(S)$\n\n**The Problem**\n\nGiven a string S, find the longest *substring* of S that is also a palindrom\n\n> Remember that substrings are consequtive\n\n**To illustrate**\n\n- a**bcb**ea $\\rightarrow$ bcb (not abcba)\n- **abbcbba**dad $\\rightarrow$ abbcbba\n\n# Solution\n\nWe shall define $opt(i, j)$ to indicate the length of the longest palindrom substring between the i'th character to the j'th character by the recurrence relation\n\nfor all i, opt(i, i) = true since a single character is a palindrom of itself.\n\nfor all i and $j > i$, opt(i, j) true if S[i] = S[j] and also opt(i + 1, j - 1) = true.\n\nFinally, to figure out the length of the longest substring that is a palindrom we need to find i and j that maximizes $j - i$ and such that opt(i, j) = true.\n\n**Psuedo**\n\n- Initialize opt\n  - $opt \\leftarrow matrix(n, n)$\n    - initialize all values false by default\n    - $\\forall i$\n      - $opt(i, i) = true$\n      - $opt(i, i + 1) \\leftarrow S[i]=S[i+1]$\n\n- Build opt in a bottom up fashion\n  - $for ~ l = 2, 3, ... n - 1$\n    - $for ~ i = 1, ..., n - l$\n      - $j \\leftarrow i +  - 1$\n      - $opt(i, j) \\leftarrow S[i] = S[j] \\land opt(i + 1, j - 1)$\n- Find the length of the longest substring that is a palindrom\n  - $for~ l = n-1, n-2, ..., 1$\n    - $for~ i = 1, 2, ..., n - l$\n      - $if~ opt(i, i + l)$\n        - return l\n\n**Time Complexity**\n\n- Initialization of opt is $O(n^2)$\n- Building opt takes $O(n^2)$ iterations\n  - Each iteration takes $O(1)$ accesses to opt\n\nSo in total, the time complexity is $O(n^2)$","html":"<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  </head>\n  <body>\n    <h1>Overview</h1>\n    <p>A string $S$ is a palindrom iff $S = reverse(S)$</p>\n    <p><strong>The Problem</strong></p>\n    <p>Given a string S, find the longest <em>substring</em> of S that is also a palindrom</p>\n    <blockquote>\n      <p>Remember that substrings are consequtive</p>\n    </blockquote>\n    <p><strong>To illustrate</strong></p>\n    <ul>\n      <li>a<strong>bcb</strong>ea $\\rightarrow$ bcb (not abcba)</li>\n      <li><strong>abbcbba</strong>dad $\\rightarrow$ abbcbba</li>\n    </ul>\n    <h1>Solution</h1>\n    <p>We shall define $opt(i, j)$ to indicate the length of the longest palindrom substring between the i'th character to the j'th character by the recurrence relation</p>\n    <p>for all i, opt(i, i) = true since a single character is a palindrom of itself.</p>\n    <p>for all i and $j > i$, opt(i, j) true if S[i] = S[j] and also opt(i + 1, j - 1) = true.</p>\n    <p>Finally, to figure out the length of the longest substring that is a palindrom we need to find i and j that maximizes $j - i$ and such that opt(i, j) = true.</p>\n    <p><strong>Psuedo</strong></p>\n    <ul>\n      <li>\n        <p>Initialize opt</p>\n        <ul>\n          <li>$opt \\leftarrow matrix(n, n)$\n            <ul>\n              <li>initialize all values false by default</li>\n              <li>$\\forall i$\n                <ul>\n                  <li>$opt(i, i) = true$</li>\n                  <li>$opt(i, i + 1) \\leftarrow S[i]=S[i+1]$</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Build opt in a bottom up fashion</p>\n        <ul>\n          <li>$for ~ l = 2, 3, ... n - 1$\n            <ul>\n              <li>$for ~ i = 1, ..., n - l$\n                <ul>\n                  <li>$j \\leftarrow i + - 1$</li>\n                  <li>$opt(i, j) \\leftarrow S[i] = S[j] \\land opt(i + 1, j - 1)$</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>\n        <p>Find the length of the longest substring that is a palindrom</p>\n        <ul>\n          <li>$for~ l = n-1, n-2, ..., 1$\n            <ul>\n              <li>$for~ i = 1, 2, ..., n - l$\n                <ul>\n                  <li>$if~ opt(i, i + l)$\n                    <ul>\n                      <li>return l</li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n    <p><strong>Time Complexity</strong></p>\n    <ul>\n      <li>Initialization of opt is $O(n^2)$</li>\n      <li>Building opt takes $O(n^2)$ iterations\n        <ul>\n          <li>Each iteration takes $O(1)$ accesses to opt</li>\n        </ul>\n      </li>\n    </ul>\n    <p>So in total, the time complexity is $O(n^2)$</p>\n  </body>\n</html>\n"}}]},"__N_SSG":true}